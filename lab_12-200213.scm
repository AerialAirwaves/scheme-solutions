#lang scheme

(define (closest-with-nums-sum n s)
	(define (sign x)
		(if (= x 0) 0
			(- (abs (+ x 1)) (abs x))
		)
	)
	(define (nums-list-func n)
		(define (iter n lst)
			(if (= n 0) lst
				(iter (quotient n 10) (cons (remainder n 10) lst))
			)
		)
		(iter n empty)
	)
	(define (nums-sum nums-list) (foldl + 0 nums-list))

	(define (iter nums-unprocessed nums-processed cdelta)
		(if (empty? nums-unprocessed) 
			(if (= cdelta 0) nums-processed
				(if (> cdelta 9)
					(iter empty (cons 9 nums-processed) (- cdelta 9))
					(iter empty (cons cdelta nums-processed) 0)
				)
			)
			
			(if (= cdelta 0) (iter (cdr nums-unprocessed) (cons (car nums-unprocessed) nums-processed) cdelta)
				(let ((cdelta-sgn (sign cdelta)))
				(let ((edge (inexact->exact (+ 4.5 (* cdelta-sgn 4.5)))))
				(let ((edge-delta (abs (- (car nums-unprocessed) edge))))
					(if (> (abs cdelta) (abs edge-delta))
						(iter (cdr nums-unprocessed) (cons edge nums-processed) (- cdelta (* cdelta-sgn edge-delta)))
						(iter (cdr nums-unprocessed) (cons (+ (car nums-unprocessed) cdelta) nums-processed) 0)
					)
				)))
			)
		)
	)

	(define (lst->num lst)
		(define (iter lst n)
			(if (empty? lst) n
				(iter (cdr lst) (+ (* 10 n) (car lst)))
			)
		)
		(iter (cdr lst) (car lst))
	)
	(define (gen-next lst)
		(define l (length lst))
		(define r (reverse lst))
		(if (<= 5 (car r))
			(build-list (+ l 1) (lambda (i) (if (= i l) 1 0)))
			(reverse (cons (+ 1 (car r) ) (cdr r)))
		)
	)


	(let ((nums-list (nums-list-func n)))
	(let ( (next (gen-next nums-list))
		   (o1 (lst->num (iter (reverse nums-list) empty (- s (nums-sum nums-list )))))
		 )
		(let ((o2 (lst->num (iter next empty (- s (nums-sum next))))))
				(if (< (abs (- n o2)) (abs (- n o1))) o2 o1)
		)
		
		
	))
)
; task 2 - exhaustive search
(define (contains-sum? lst)
	(define (chooseC lst0 lst1 a b)
		(if (empty? lst0) #f
			(if (= (car lst0) (+ a b))
				(list a b (car lst0))
				(chooseC (cdr lst0) lst1 a b)
			)
		)
	)
	(define (chooseB lst0 lst1 a)
		(if (empty? lst0) #f
			(let ((new-l (remove (car lst0) lst1)))
			(let ((cand (chooseC new-l new-l a (car lst0)) ))
				(or cand (chooseB (cdr lst0) lst1 a))
			))
		)
	)
	(define (chooseA lst0)
		(if (empty? lst0) #f
			(let ((new-l (remove (car lst0) lst)))
			(let ((cand (chooseB new-l new-l (car lst0)) ))
				(or cand (chooseA (cdr lst0)))
			))
		)
	)

	(chooseA lst)
)

; task 3
(define (mxPow a b)
	(if (< (min a b) 2) #f
		(if (= (remainder (max a b) (min a b)) 0)
			(if (= 1 (/ a b))  a
				(mxPow (/ (max a b) (min a b)) (min a b))
			)
			#f
		)
	)
)
; task 4
(define (string->sum str)
	(define (iter lst c r)
		(if (empty? lst) (+ c r)
			(if (char-numeric? (car lst)) 
				(iter (cdr lst) (+ (* c 10) (- (char->integer (car lst)) 48) ) r)
				(iter (cdr lst) 0 (+ r c))
			)
		)
	)
	(iter (string->list str) 0 0)
)
; task 5
(define (max-prime n)
	(define (prime? n) 
		(define (sIsPrime q)
			(if (and (<= (* q q) n) (not (= 0 (remainder n q))) ) (sIsPrime (+ q 2))
				(> (* q q) n)
			)
		)
		(if (= 0 (remainder n 2)) (= n 2)
			(sIsPrime 3)
		)
	)
	(define (lst->num lst)
		(define (iter lst n)
			(if (empty? lst) n
				(iter (cdr lst) (+ (* 10 n) (car lst)))
			)
		)
		(iter (cdr lst) (car lst))
	)
	(define (num->lst n)
		(define (iter n lst)
			(if (= n 0) lst
				(iter (quotient n 10) (cons (remainder n 10) lst))
			)
		)
		(iter n empty)
	)
	(define (iter2 l r k m)
		(if (= k 10) m
			(let ((n (lst->num (append (reverse (cons k l)) r))))
				(iter2 l r (+ k 1)
					(if (and (prime? n) (> n m)) n m)
				)
			)
		)
	)
	(define (iter l r m)
		(if (equal? -1 l) m
			(let ((mc (iter2 l r 0 -1)))
				(iter (if (empty? l) -1 (cdr l)) (if (empty? l) r (cons (car l) r)) (if (> mc m) mc m))
			)
		)
	)
	(define out (iter (reverse (num->lst n)) empty -1))
	(if (= out -1) #f out)
)