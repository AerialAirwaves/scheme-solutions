#lang scheme

; task 1
(define (isolated-nodes-quantity graphAdjacencyMatriceFile)
	(define in (open-input-file graphAdjacencyMatriceFile))
	(define n (read in))
	(define stopPos (* n n))

	(define (iter pos q invalid-lst)
		(define val (read in))
		(if (= pos stopPos) (begin (close-input-port in) q)
			(begin
				(if (= val 1)
					(let ((src (quotient pos n))
						 (dest (remainder pos n)))
					(let ((src-invalid?  (member src invalid-lst))
						  (dest-invalid? (member dest invalid-lst)))
						(iter (+ pos 1)
							(- q (if src-invalid? 0 1) (if dest-invalid? 0 1) (if (and (not src-invalid?) (not dest-invalid?) (= src dest)) -1 0))
							((lambda (inv) (if dest-invalid? inv (cons dest inv)))
								(if src-invalid? invalid-lst (cons src invalid-lst))
							)
						)
					)
					)
					(iter (+ pos 1) q invalid-lst)
				)
			)
		)
	)
	(iter 0 n null)	
)

; task 2
(define (graph-complete? graphAdjacencyListsFile)
	(define in (open-input-file graphAdjacencyListsFile))
	(define n (read in))
	(define template (build-list n values))
	(define (check i)
		(define (iter k tpl)
			(if (= k (- n 1)) (and (empty? (cdr tpl)) (= i (car tpl)))
			(let ((r (remove (read in) tpl)))
				(if (or (equal? tpl r) (empty? tpl)) #f
					(iter (+ k 1) r)
				)
			)
			)
		)
		(iter 0 template)
	)
	(define (iter t)
		(define q (read in))
		(if (= t n) (begin (close-input-port in) #t)
			(if (= q (- n 1))
				(if (check t)
					(iter (add1 t)) #f
				)
				#f
			)
		)
	)
	(iter 0)
)

; task 3
(define (grAdjLists->graph-edges graphAdjacencyListsFile outFile)
	(define in (open-input-file graphAdjacencyListsFile))
	(define out (open-output-file outFile #:exists 'replace))
	(define n (read in))
	(define (iter k)
		(if (= k n) (close-output-port out)
			(begin
				(build-list (read in)
					(lambda (x)
						(write k out)
						(display #\space out)
						(writeln (read in) out)
					)
				)
				(iter (+ k 1))
			)
		)
	)
	(iter 0)
)

; task 4
(define (grAdjMatr->graph-edges graphAdjacencyMatriceFile)
	(define in (open-input-file graphAdjacencyMatriceFile))
	(define n (read in))
	(define stopPos (* n n))

	(define (iter pos edges)
		(define k (read in))
		(define src  (quotient  pos n))
		(define dest (remainder pos n))
		(if (= pos stopPos) edges
			(iter (add1 pos)
				(if (= k 0) edges
					(foldl (lambda (n p) (cons (cons src dest) p)) edges (build-list k values))
				)
			)
		)
	)
	(iter 0 null)
)

; task 5

(define (grAdjLists->grAdjMatr lstF matrF)
	(define in (open-input-file lstF))
	(define out (open-output-file matrF #:exists 'replace))
	(define n (read in))
	(displayln n out)

	(define (iter k)
		(define q (read in))
		(if (= k n) (close-output-port out)
			(begin
				(foldl
					(lambda (n p)
						(write n out)
						(display #\space out)
					)
					null
					(foldl
						(lambda (n p)
							(let ((i (read in))) 
								(list-set p i (add1 (list-ref p i)))
							)
						)
						(build-list n (lambda (x) 0))
						(build-list q values)
					)
				)
				(display #\newline out)
				(iter (add1 k))
			)
		)
	)
	(iter 0)
)